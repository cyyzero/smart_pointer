#ifndef UNIQUE_PTR_H
#define UNIQUE_PTR_H

#include <type_traits>
#include <tuple>
namespace smart_ptr
{

    // Primary template of default_delete, used by unique_ptr
    template<typename Tp>
    struct default_delete
    {
        constexpr default_delete() noexcept = default;

        // Allows conversion from a deleter for arrays of another type
        template<typename Up, typename = typename enable_if<std::is_convertible<Up*, Tp*>::value>::type>
            default_delete(const default_delete<Up>&) noexcept {}

        void operator()(Tp* ptr) const
        {
            static_assert(!std::is_void<Tp>::value,
                          "can't delete pointer to incomplete type");
            static_assert(sizeof(Tp) > 0,
                          "can't delete pointer to incomplete type");
            delete ptr;
        }
    };

    // Specialization for arrays, default_delete.
    template<typename Tp>
    struct default_delete<Tp[]>
    {
    public:
        constexpr default_delete() noexcept = default;

        operator()(Tp* ptr) const
        {
            static_assert(sizeof(Tp) > 0,
                          "can't delete pointer to incomplete type");
            delete [] ptr;
        }
    };

    template<typename T, typename Deleter = default_delete<T>>
    class unique_ptr
    {
    public:
        using pointer = T*;
        using element_type = T;
        using deleter_type = Deleter;

        //constructors
        constexpr unique_ptr() noexcept
            :M_t()
        {
            static_assert(!std::is_pointer<deleter_type>::value,
                          "constructed with null function pointer deleter");
        }

        explicit
        unique_ptr(pointer p) noexcept
            :M_t(p, deleter_type())
        {
            static_assert(!std::is_pointer<deleter_type>::value,
                          "constructed with null function pointer deleter");
        }

        unique_ptr(pointer p,
                   typename conditional<std::is_reference<deleter_type>::value,
                                        deleter_type,
                                        const deleter_type&>::type d) noexcept
            : M_t(p, d) { }

        unique_ptr(pointer p, typename std::remove_reference<delete_type>::type&& d) noexcept
            : M_t(std::move(p), std::move(d))
        {
            static_assert(!std::is_reference<deleter_type>::value,
                          "rvalue deleter bound to reference");
        }

        unique_ptr(unique_ptr &&u) noexcept
            : M_t(u.release(), std::forward<deleter_type>(u.get_deleter())) { }

        // destructor
        ~unique_ptr()
        {
            auto &ptr = std::get<0>(M_t);
            if (ptr != nullptr)
            {
                get_deleter()(ptr);
            }
            ptr = nullptr;
        }
        

        constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }
        
        // Assignment
        
        unique_ptr& operator=(unique_ptr&& u) noexcept
        {
            reset(u.release());
            get_deleter() = std::forward<deleter_type>(u.get_deleter());
            return *this;
        }
        
        unique_ptr& operator=(nullptr_t) noexcept
        {
            reset();
            return *this;
        }
        
        // Observers
        
        /// Access an element of owned array
        typename std::add_lvalue_reference<element_type>::type
        operator[](size_t i) const
        {
            return get()[i];
        }
        
        
        /// Return the stored pointer
        pointer get() const noexcept
        {
            return std::get<0>(M_t);
        }
        
        /// Return a reference to the stored deleter.
        deleter_type& get_deleter() noexcept
        {
            return std::get<1>(M_t);
        }
        
        /// Return a reference to the stored deleter.
        const deleter_type& get_deleter() const noexcept
        {
            return std::get<1>(M_t);
        }
        
        /// Return true if stored pointer is not null
        explicit operator bool() const noexcept
        {
            return get() == nullptr ? false : true;
        }
        
        // Modifiers
        
        /// Release ownership of any stored pointer.
        pointer release() noexcept
        {
            pointer p = get();
            std::get<0>(M_t) = nullptr;
            return p;
        }
        
        /// Replace the stored pointer.
        void reset(pointer p = nullptr) noexcept
        {
            using std::swap;
            swap(std::get<0>(M_t), p);
            if (p != nullptr)
            {
                get_deleter()(p);
            }
        }
        
        /// Exchange the pointer and deleter with another object.
        void swap(unqiue_ptr& u) noexcept
        {
            using std::swap;
            swap(M_t, u.M_t);
        }
        
        // Disable copy from lvalue.
        unique_ptr(const unqiue_ptr&) = delete;
        unique_ptr& operator=(const unique_ptr&) = delete;
     private:
        std::tuple<pointer, Deleter> M_t;

    }
}
#endif // UNIQUE_PTR_H
